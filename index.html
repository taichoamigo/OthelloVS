<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>オセロゲーム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --board-bg: #065f46; /* emerald-800 */
            --cell-bg: #047857; /* emerald-700 */
            --cell-hover-bg: #059669; /* emerald-600 */
            --black-piece: #1f2937; /* gray-800 */
            --white-piece: #f9fafb; /* gray-50 */
            --text-color: #d1d5db; /* gray-300 */
            --board-size: 8; /* デフォルトサイズ */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* gray-900 */
            color: var(--text-color);
        }
        .board {
            display: grid;
            /* CSS変数を使ってグリッドのサイズを動的に変更 */
            grid-template-columns: repeat(var(--board-size), 1fr);
            grid-template-rows: repeat(var(--board-size), 1fr);
            width: 90vw;
            height: 90vw;
            max-width: 500px;
            max-height: 500px;
            background-color: var(--board-bg);
            border: 4px solid #064e3b; /* emerald-900 */
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .cell {
            background-color: var(--cell-bg);
            border: 1px solid var(--board-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .cell:hover {
            background-color: var(--cell-hover-bg);
        }
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.3);
            transform: scale(0);
            animation: place-piece 0.3s forwards ease-out;
        }
        .piece.black { background-color: var(--black-piece); }
        .piece.white { background-color: var(--white-piece); }
        
        .piece.flip-to-white { animation: flip-to-white 0.5s forwards; }
        .piece.flip-to-black { animation: flip-to-black 0.5s forwards; }

        @keyframes place-piece {
            from { transform: scale(0); }
            to { transform: scale(1); }
        }

        @keyframes flip-to-white {
            0% { transform: scaleX(1); background-color: var(--black-piece); }
            50% { transform: scaleX(0); background-color: var(--black-piece); }
            51% { background-color: var(--white-piece); }
            100% { transform: scaleX(1); background-color: var(--white-piece); }
        }

        @keyframes flip-to-black {
            0% { transform: scaleX(1); background-color: var(--white-piece); }
            50% { transform: scaleX(0); background-color: var(--white-piece); }
            51% { background-color: var(--black-piece); }
            100% { transform: scaleX(1); background-color: var(--black-piece); }
        }

        .valid-move-hint {
            width: 30%;
            height: 30%;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body class="bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-3xl font-bold text-center text-white mb-4">オセロ</h1>

    <!-- 設定画面 -->
    <div id="setup-screen" class="w-full max-w-md text-center">
        <label for="size-select" class="text-lg mb-2 block">盤面のサイズを選んでください:</label>
        <select id="size-select" class="bg-gray-800 border border-gray-700 text-white text-sm rounded-lg focus:ring-emerald-500 focus:border-emerald-500 block w-full p-2.5 mb-4">
            <option value="6">6x6</option>
            <option value="8" selected>8x8</option>
            <option value="10">10x10</option>
        </select>
        <button id="start-game-btn" class="w-full px-6 py-3 bg-emerald-600 text-white font-bold rounded-lg shadow-md hover:bg-emerald-700 transition-colors duration-200">
            ゲーム開始
        </button>
    </div>

    <!-- ゲーム画面 (最初は非表示) -->
    <div id="game-screen" class="hidden w-full max-w-md">
        <div class="flex justify-between items-center bg-gray-800 p-3 rounded-lg shadow-lg mb-4">
            <div id="score-black" class="flex items-center space-x-2 text-xl font-semibold">
                <div class="w-6 h-6 rounded-full bg-gray-800 border-2 border-white"></div>
                <span>黒: 2</span>
            </div>
            <div id="turn-indicator" class="text-lg font-medium text-center px-4 py-1 rounded-md"></div>
            <div id="score-white" class="flex items-center space-x-2 text-xl font-semibold">
                <div class="w-6 h-6 rounded-full bg-white"></div>
                <span>白: 2</span>
            </div>
        </div>

        <div id="board" class="board mx-auto"></div>

        <div id="message-area" class="mt-4 text-xl h-8 text-center font-bold"></div>

        <button id="back-to-setup-btn" class="w-full mt-4 px-6 py-3 bg-gray-600 text-white font-bold rounded-lg shadow-md hover:bg-gray-700 transition-colors duration-200">
            設定に戻る
        </button>
    </div>

    <script>
        // DOM要素の取得
        const setupScreen = document.getElementById('setup-screen');
        const gameScreen = document.getElementById('game-screen');
        const sizeSelect = document.getElementById('size-select');
        const startGameBtn = document.getElementById('start-game-btn');
        const backToSetupBtn = document.getElementById('back-to-setup-btn');

        const boardElement = document.getElementById('board');
        const scoreBlackElement = document.getElementById('score-black').querySelector('span');
        const scoreWhiteElement = document.getElementById('score-white').querySelector('span');
        const turnIndicatorElement = document.getElementById('turn-indicator');
        const messageAreaElement = document.getElementById('message-area');

        // 定数
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;
        const directions = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1], [1, 0], [1, 1]
        ];

        // ゲームの状態変数
        let boardSize;
        let boardState;
        let currentPlayer;
        let gameOver;

        // ゲーム開始ボタンのイベント
        startGameBtn.addEventListener('click', () => {
            const selectedSize = parseInt(sizeSelect.value);
            setupScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            initGame(selectedSize);
        });

        // 設定に戻るボタンのイベント
        backToSetupBtn.addEventListener('click', () => {
            gameScreen.classList.add('hidden');
            setupScreen.classList.remove('hidden');
        });

        // ゲームの初期化
        function initGame(size) {
            boardSize = size;
            // CSS変数を更新して盤面のグリッドを正しく設定
            document.documentElement.style.setProperty('--board-size', boardSize);

            boardState = Array(boardSize).fill(0).map(() => Array(boardSize).fill(EMPTY));
            const mid1 = boardSize / 2 - 1;
            const mid2 = boardSize / 2;
            boardState[mid1][mid1] = WHITE;
            boardState[mid1][mid2] = BLACK;
            boardState[mid2][mid1] = BLACK;
            boardState[mid2][mid2] = WHITE;
            
            currentPlayer = BLACK;
            gameOver = false;
            
            renderBoard();
            updateUI();
            messageAreaElement.textContent = '';
        }

        // ボードの描画
        function renderBoard() {
            boardElement.innerHTML = '';
            const validMoves = getValidMoves(currentPlayer);

            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    const pieceValue = boardState[row][col];
                    if (pieceValue !== EMPTY) {
                        const piece = document.createElement('div');
                        piece.className = `piece ${pieceValue === BLACK ? 'black' : 'white'}`;
                        // アニメーションなしで表示
                        piece.style.animation = 'none';
                        piece.style.transform = 'scale(1)';
                        cell.appendChild(piece);
                    } else {
                        if (validMoves.some(move => move.row === row && move.col === col)) {
                            const hint = document.createElement('div');
                            hint.className = 'valid-move-hint';
                            hint.style.backgroundColor = currentPlayer === BLACK ? 'rgba(0, 0, 0, 0.3)' : 'rgba(255, 255, 255, 0.3)';
                            cell.appendChild(hint);
                        }
                    }
                    boardElement.appendChild(cell);
                }
            }
        }

        // UIの更新
        function updateUI() {
            let blackScore = 0;
            let whiteScore = 0;
            boardState.flat().forEach(p => {
                if (p === BLACK) blackScore++;
                if (p === WHITE) whiteScore++;
            });

            scoreBlackElement.textContent = `黒: ${blackScore}`;
            scoreWhiteElement.textContent = `白: ${whiteScore}`;
            
            if (gameOver) return;

            const turnIndicatorBlack = document.getElementById('score-black').querySelector('div');
            const turnIndicatorWhite = document.getElementById('score-white').querySelector('div');

            if (currentPlayer === BLACK) {
                turnIndicatorElement.textContent = "黒の番";
                turnIndicatorElement.style.color = 'var(--black-piece)';
                turnIndicatorElement.style.backgroundColor = 'var(--white-piece)';
                turnIndicatorBlack.classList.add('ring-2', 'ring-offset-2', 'ring-offset-gray-800', 'ring-white');
                turnIndicatorWhite.classList.remove('ring-2', 'ring-offset-2', 'ring-offset-gray-800', 'ring-white');
            } else {
                turnIndicatorElement.textContent = "白の番";
                turnIndicatorElement.style.color = 'var(--white-piece)';
                turnIndicatorElement.style.backgroundColor = 'var(--black-piece)';
                turnIndicatorWhite.classList.add('ring-2', 'ring-offset-2', 'ring-offset-gray-800', 'ring-white');
                turnIndicatorBlack.classList.remove('ring-2', 'ring-offset-2', 'ring-offset-gray-800', 'ring-white');
            }
        }

        // クリックイベントの処理
        boardElement.addEventListener('click', (e) => {
            if (gameOver) return;
            const cell = e.target.closest('.cell');
            if (!cell) return;

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            const piecesToFlip = getPiecesToFlip(row, col, currentPlayer);

            if (piecesToFlip.length > 0) {
                boardState[row][col] = currentPlayer;
                piecesToFlip.forEach(p => { boardState[p.row][p.col] = currentPlayer; });
                
                renderBoardWithAnimation(row, col, piecesToFlip);
                
                setTimeout(switchTurn, 600);
            }
        });
        
        // アニメーション付きでボードを再描画
        function renderBoardWithAnimation(placedRow, placedCol, flippedPieces) {
            boardElement.innerHTML = '';
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    const pieceValue = boardState[row][col];
                    if (pieceValue !== EMPTY) {
                        const piece = document.createElement('div');
                        const isFlipped = flippedPieces.some(p => p.row === row && p.col === col);
                        const isPlaced = (row === placedRow && col === placedCol);

                        if (isPlaced) {
                             piece.className = `piece ${pieceValue === BLACK ? 'black' : 'white'}`;
                        } else if (isFlipped) {
                            const opponentColor = pieceValue === WHITE ? 'black' : 'white';
                            const flipClass = pieceValue === WHITE ? 'flip-to-white' : 'flip-to-black';
                            piece.className = `piece ${opponentColor} ${flipClass}`;
                        } else {
                            piece.className = `piece ${pieceValue === BLACK ? 'black' : 'white'}`;
                            piece.style.animation = 'none';
                            piece.style.transform = 'scale(1)';
                        }
                        cell.appendChild(piece);
                    }
                    boardElement.appendChild(cell);
                }
            }
        }

        // ターンの交代
        function switchTurn() {
            currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
            
            if (getValidMoves(currentPlayer).length > 0) {
                renderBoard();
                updateUI();
            } else {
                messageAreaElement.textContent = `${currentPlayer === BLACK ? '黒' : '白'}はパスです。`;
                currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
                
                if (getValidMoves(currentPlayer).length > 0) {
                    setTimeout(() => {
                        messageAreaElement.textContent = '';
                        renderBoard();
                        updateUI();
                    }, 1500);
                } else {
                    endGame();
                }
            }
        }
        
        // ゲーム終了処理
        function endGame() {
            gameOver = true;
            let blackScore = 0;
            let whiteScore = 0;
            boardState.flat().forEach(p => {
                if (p === BLACK) blackScore++;
                if (p === WHITE) whiteScore++;
            });
            
            let resultMessage = '';
            if (blackScore > whiteScore) {
                resultMessage = `黒の勝ち！ (${blackScore}対${whiteScore})`;
            } else if (whiteScore > blackScore) {
                resultMessage = `白の勝ち！ (${blackScore}対${whiteScore})`;
            } else {
                resultMessage = `引き分け (${blackScore}対${whiteScore})`;
            }
            messageAreaElement.textContent = resultMessage;
            turnIndicatorElement.textContent = "ゲーム終了";
            turnIndicatorElement.style.backgroundColor = '#4b5563';
            turnIndicatorElement.style.color = 'white';
        }

        // ひっくり返る石のリストを返す
        function getPiecesToFlip(row, col, player) {
            if (boardState[row][col] !== EMPTY) return [];

            const opponent = (player === BLACK) ? WHITE : BLACK;
            let piecesToFlip = [];

            for (const [dr, dc] of directions) {
                let line = [];
                let r = row + dr;
                let c = col + dc;

                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize && boardState[r][c] === opponent) {
                    line.push({ row: r, col: c });
                    r += dr;
                    c += dc;
                }

                if (r >= 0 && r < boardSize && c >= 0 && c < boardSize && boardState[r][c] === player) {
                    piecesToFlip = piecesToFlip.concat(line);
                }
            }
            return piecesToFlip;
        }
        
        // 有効な手のリストを返す
        function getValidMoves(player) {
            const moves = [];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (boardState[row][col] === EMPTY) {
                        if (getPiecesToFlip(row, col, player).length > 0) {
                            moves.push({ row, col });
                        }
                    }
                }
            }
            return moves;
        }
    </script>
</body>
</html>
